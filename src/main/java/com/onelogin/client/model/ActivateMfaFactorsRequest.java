/*
 * OneLogin API
 * OpenAPI Specification for OneLogin
 *
 * The version of the OpenAPI document: 3.1.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.onelogin.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.onelogin.client.JSON;

/**
 * ActivateMfaFactorsRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-03-16T12:13:23.145217-07:00[America/Los_Angeles]")
public class ActivateMfaFactorsRequest {
  public static final String SERIALIZED_NAME_STATE_TOKEN_EXPIRES_IN = "state_token_expires_in";
  @SerializedName(SERIALIZED_NAME_STATE_TOKEN_EXPIRES_IN)
  private Integer stateTokenExpiresIn;

  public static final String SERIALIZED_NAME_NUMERIC_SMS_OTP = "numeric_sms_otp";
  @SerializedName(SERIALIZED_NAME_NUMERIC_SMS_OTP)
  private Boolean numericSmsOtp;

  public static final String SERIALIZED_NAME_SMS_MESSAGE = "sms_message";
  @SerializedName(SERIALIZED_NAME_SMS_MESSAGE)
  private String smsMessage;

  public ActivateMfaFactorsRequest() {
  }

  public ActivateMfaFactorsRequest stateTokenExpiresIn(Integer stateTokenExpiresIn) {
    
    this.stateTokenExpiresIn = stateTokenExpiresIn;
    return this;
  }

   /**
   * Optional. Sets the window of time in seconds that the factor must be verified within. Defaults to 120 seconds (2 minutes). Max 900 seconds (15 minutes).
   * @return stateTokenExpiresIn
  **/
  @javax.annotation.Nullable

  public Integer getStateTokenExpiresIn() {
    return stateTokenExpiresIn;
  }


  public void setStateTokenExpiresIn(Integer stateTokenExpiresIn) {
    this.stateTokenExpiresIn = stateTokenExpiresIn;
  }


  public ActivateMfaFactorsRequest numericSmsOtp(Boolean numericSmsOtp) {
    
    this.numericSmsOtp = numericSmsOtp;
    return this;
  }

   /**
   * Optional. Defaults to false. Only applies to SMS factor. When set to &#x60;true&#x60; a 6 digit numeric code will be sent to the user instead of the standard code which is alphanumeric.
   * @return numericSmsOtp
  **/
  @javax.annotation.Nullable

  public Boolean getNumericSmsOtp() {
    return numericSmsOtp;
  }


  public void setNumericSmsOtp(Boolean numericSmsOtp) {
    this.numericSmsOtp = numericSmsOtp;
  }


  public ActivateMfaFactorsRequest smsMessage(String smsMessage) {
    
    this.smsMessage = smsMessage;
    return this;
  }

   /**
   * Optional. Only applies to SMS factor. A message template that will be sent via SMS. Max length of the message after template items are inserted is 160 characters. The following template variables can be included in the message. - {{otp_code}} - The security code. - {{expiration}} - The number of minutes until the one time code expires.
   * @return smsMessage
  **/
  @javax.annotation.Nullable

  public String getSmsMessage() {
    return smsMessage;
  }


  public void setSmsMessage(String smsMessage) {
    this.smsMessage = smsMessage;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ActivateMfaFactorsRequest activateMfaFactorsRequest = (ActivateMfaFactorsRequest) o;
    return Objects.equals(this.stateTokenExpiresIn, activateMfaFactorsRequest.stateTokenExpiresIn) &&
        Objects.equals(this.numericSmsOtp, activateMfaFactorsRequest.numericSmsOtp) &&
        Objects.equals(this.smsMessage, activateMfaFactorsRequest.smsMessage);
  }

  @Override
  public int hashCode() {
    return Objects.hash(stateTokenExpiresIn, numericSmsOtp, smsMessage);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ActivateMfaFactorsRequest {\n");
    sb.append("    stateTokenExpiresIn: ").append(toIndentedString(stateTokenExpiresIn)).append("\n");
    sb.append("    numericSmsOtp: ").append(toIndentedString(numericSmsOtp)).append("\n");
    sb.append("    smsMessage: ").append(toIndentedString(smsMessage)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("state_token_expires_in");
    openapiFields.add("numeric_sms_otp");
    openapiFields.add("sms_message");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to ActivateMfaFactorsRequest
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!ActivateMfaFactorsRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ActivateMfaFactorsRequest is not found in the empty JSON string", ActivateMfaFactorsRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!ActivateMfaFactorsRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ActivateMfaFactorsRequest` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      if ((jsonObj.get("sms_message") != null && !jsonObj.get("sms_message").isJsonNull()) && !jsonObj.get("sms_message").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sms_message` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sms_message").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ActivateMfaFactorsRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ActivateMfaFactorsRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ActivateMfaFactorsRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ActivateMfaFactorsRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<ActivateMfaFactorsRequest>() {
           @Override
           public void write(JsonWriter out, ActivateMfaFactorsRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ActivateMfaFactorsRequest read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ActivateMfaFactorsRequest given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ActivateMfaFactorsRequest
  * @throws IOException if the JSON string is invalid with respect to ActivateMfaFactorsRequest
  */
  public static ActivateMfaFactorsRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ActivateMfaFactorsRequest.class);
  }

 /**
  * Convert an instance of ActivateMfaFactorsRequest to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

