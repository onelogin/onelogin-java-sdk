/*
 * OneLogin API
 * OpenAPI Specification for OneLogin
 *
 * The version of the OpenAPI document: 3.1.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.onelogin.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.onelogin.client.JSON;

/**
 * UpdatePasswordSecureRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-07-18T11:53:48.226013-07:00[America/Los_Angeles]")
public class UpdatePasswordSecureRequest {
  public static final String SERIALIZED_NAME_PASSWORD = "password";
  @SerializedName(SERIALIZED_NAME_PASSWORD)
  private String password;

  public static final String SERIALIZED_NAME_PASSWORD_CONFIRMATION = "password_confirmation";
  @SerializedName(SERIALIZED_NAME_PASSWORD_CONFIRMATION)
  private String passwordConfirmation;

  public static final String SERIALIZED_NAME_PASSWORD_ALGORITHM = "password_algorithm";
  @SerializedName(SERIALIZED_NAME_PASSWORD_ALGORITHM)
  private String passwordAlgorithm;

  public static final String SERIALIZED_NAME_PASSWORD_SALT = "password_salt";
  @SerializedName(SERIALIZED_NAME_PASSWORD_SALT)
  private String passwordSalt;

  public UpdatePasswordSecureRequest() {
  }

  public UpdatePasswordSecureRequest password(String password) {
    
    this.password = password;
    return this;
  }

   /**
   * Set to the password value using a SHA-256-encoded value. If you are including your own password_salt value in your request, prepend the salt value to the cleartext password value before SHA-256-encoding it. For example, if your salt value is hello and your cleartext password value is password, the value you need to SHA-256-encode is hellopassword. The resulting encoded value would be b1c788abac15390de987ad17b65ac73c9b475d428a51f245c645a442fddd078b. Note that the alpha characters in this has must all be lower case.
   * @return password
  **/
  @javax.annotation.Nonnull
  public String getPassword() {
    return password;
  }


  public void setPassword(String password) {
    this.password = password;
  }


  public UpdatePasswordSecureRequest passwordConfirmation(String passwordConfirmation) {
    
    this.passwordConfirmation = passwordConfirmation;
    return this;
  }

   /**
   * This value must match the password value.
   * @return passwordConfirmation
  **/
  @javax.annotation.Nonnull
  public String getPasswordConfirmation() {
    return passwordConfirmation;
  }


  public void setPasswordConfirmation(String passwordConfirmation) {
    this.passwordConfirmation = passwordConfirmation;
  }


  public UpdatePasswordSecureRequest passwordAlgorithm(String passwordAlgorithm) {
    
    this.passwordAlgorithm = passwordAlgorithm;
    return this;
  }

   /**
   * Set to salt+sha256.
   * @return passwordAlgorithm
  **/
  @javax.annotation.Nonnull
  public String getPasswordAlgorithm() {
    return passwordAlgorithm;
  }


  public void setPasswordAlgorithm(String passwordAlgorithm) {
    this.passwordAlgorithm = passwordAlgorithm;
  }


  public UpdatePasswordSecureRequest passwordSalt(String passwordSalt) {
    
    this.passwordSalt = passwordSalt;
    return this;
  }

   /**
   * Optional. If your password hash has been salted then you can provide the salt used in this param. This assumes that the salt was prepended to the password before doing the SHA256 hash. The API supports a salt value that is up to 40 characters long.
   * @return passwordSalt
  **/
  @javax.annotation.Nullable
  public String getPasswordSalt() {
    return passwordSalt;
  }


  public void setPasswordSalt(String passwordSalt) {
    this.passwordSalt = passwordSalt;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UpdatePasswordSecureRequest updatePasswordSecureRequest = (UpdatePasswordSecureRequest) o;
    return Objects.equals(this.password, updatePasswordSecureRequest.password) &&
        Objects.equals(this.passwordConfirmation, updatePasswordSecureRequest.passwordConfirmation) &&
        Objects.equals(this.passwordAlgorithm, updatePasswordSecureRequest.passwordAlgorithm) &&
        Objects.equals(this.passwordSalt, updatePasswordSecureRequest.passwordSalt);
  }

  @Override
  public int hashCode() {
    return Objects.hash(password, passwordConfirmation, passwordAlgorithm, passwordSalt);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UpdatePasswordSecureRequest {\n");
    sb.append("    password: ").append(toIndentedString(password)).append("\n");
    sb.append("    passwordConfirmation: ").append(toIndentedString(passwordConfirmation)).append("\n");
    sb.append("    passwordAlgorithm: ").append(toIndentedString(passwordAlgorithm)).append("\n");
    sb.append("    passwordSalt: ").append(toIndentedString(passwordSalt)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("password");
    openapiFields.add("password_confirmation");
    openapiFields.add("password_algorithm");
    openapiFields.add("password_salt");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("password");
    openapiRequiredFields.add("password_confirmation");
    openapiRequiredFields.add("password_algorithm");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to UpdatePasswordSecureRequest
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!UpdatePasswordSecureRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in UpdatePasswordSecureRequest is not found in the empty JSON string", UpdatePasswordSecureRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!UpdatePasswordSecureRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `UpdatePasswordSecureRequest` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : UpdatePasswordSecureRequest.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("password").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `password` to be a primitive type in the JSON string but got `%s`", jsonObj.get("password").toString()));
      }
      if (!jsonObj.get("password_confirmation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `password_confirmation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("password_confirmation").toString()));
      }
      if (!jsonObj.get("password_algorithm").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `password_algorithm` to be a primitive type in the JSON string but got `%s`", jsonObj.get("password_algorithm").toString()));
      }
      if ((jsonObj.get("password_salt") != null && !jsonObj.get("password_salt").isJsonNull()) && !jsonObj.get("password_salt").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `password_salt` to be a primitive type in the JSON string but got `%s`", jsonObj.get("password_salt").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!UpdatePasswordSecureRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'UpdatePasswordSecureRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<UpdatePasswordSecureRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(UpdatePasswordSecureRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<UpdatePasswordSecureRequest>() {
           @Override
           public void write(JsonWriter out, UpdatePasswordSecureRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public UpdatePasswordSecureRequest read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of UpdatePasswordSecureRequest given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of UpdatePasswordSecureRequest
  * @throws IOException if the JSON string is invalid with respect to UpdatePasswordSecureRequest
  */
  public static UpdatePasswordSecureRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, UpdatePasswordSecureRequest.class);
  }

 /**
  * Convert an instance of UpdatePasswordSecureRequest to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

